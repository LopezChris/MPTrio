<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>SJSU One API: /var/www/html/SJSU-DEV-Linux/firmware/default/lib/L2_Drivers/can.h File Reference</title>
        <!--<link href="../../tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="../../dynsections.js"></script>
        <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
        <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="../../doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">SJSU One API </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part --><!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_d9edf6c004b4a7ff14fe9ae7a92214ee.html">firmware</a></li><li class="navelem"><a class="el" href="../../dir_1cd4931aa993753d363e928640341ec9.html">default</a></li><li class="navelem"><a class="el" href="../../dir_98f6e3228cef689a79f0d5c275585dc1.html">lib</a></li><li class="navelem"><a class="el" href="../../dir_5551de2aa075800c76149d51b07e7ada.html">L2_Drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">can.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for can.h:</div>
<div class="dyncontent">
<div class="center"><img src="../../d2/d9f/can_8h__incl.png" border="0" usemap="#_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L2__Drivers_2can_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/d18/can_8h__dep__incl.png" border="0" usemap="#_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L2__Drivers_2can_8hdep" alt=""/></div>
<map name="_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L2__Drivers_2can_8hdep" id="_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L2__Drivers_2can_8hdep">
<area shape="rect" id="node2" href="../../d0/dd7/can_8c.html" title="/var/www/html/SJSU\l&#45;DEV&#45;Linux/firmware\l/default/lib/L2_Drivers\l/src/can.c" alt="" coords="23,109,173,180"/>
</map>
</div>
</div>
<p><a href="../../d7/da8/can_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9a/unioncan__data__t.html">can_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d3f/struct____attribute____.html">__attribute__</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d3f/struct____attribute____.html">__attribute__</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d3f/struct____attribute____.html">__attribute__</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/da8/structcan__std__grp__id__t.html">can_std_grp_id_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d3f/struct____attribute____.html">__attribute__</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d39/structcan__ext__grp__id__t.html">can_ext_grp_id_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a70166a12001edeee7860a1257037be44"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a70166a12001edeee7860a1257037be44">can_void_func_t</a>) (uint32_t)</td></tr>
<tr class="separator:a70166a12001edeee7860a1257037be44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac94be130a7809f09346c1b89b3d44bdd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> { <a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdda5d6d98ee073edc2321bb51b10db12888">can1</a>, 
<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdda23699735f0e1c354cceae24f5c2cd9fe">can2</a>, 
<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bddab38d40c499b095adf4aca181ecb10d59">can_max</a>
 }<tr class="memdesc:ac94be130a7809f09346c1b89b3d44bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CAN BUS type.  <a href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac94be130a7809f09346c1b89b3d44bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0e186b576e535b32e6a884a89a4dcb0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a0e186b576e535b32e6a884a89a4dcb0e">CAN_init</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can, uint32_t baudrate_kbps, uint16_t rxq_size, uint16_t txq_size, <a class="el" href="../../d7/da8/can_8h.html#a70166a12001edeee7860a1257037be44">can_void_func_t</a> bus_off_cb, <a class="el" href="../../d7/da8/can_8h.html#a70166a12001edeee7860a1257037be44">can_void_func_t</a> data_ovr_cb)</td></tr>
<tr class="separator:a0e186b576e535b32e6a884a89a4dcb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f27267c493bfefca258bb24d5c17704"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a6f27267c493bfefca258bb24d5c17704">CAN_rx</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can, can_msg_t *msg, uint32_t timeout_ms)</td></tr>
<tr class="separator:a6f27267c493bfefca258bb24d5c17704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ba2fcfcdfff25071aed5a361f4b72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a595ba2fcfcdfff25071aed5a361f4b72">CAN_tx</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can, can_msg_t *msg, uint32_t timeout_ms)</td></tr>
<tr class="separator:a595ba2fcfcdfff25071aed5a361f4b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1872008530bb84d39166c7b71642e3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#aec1872008530bb84d39166c7b71642e3">CAN_get_rx_dropped_count</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can)</td></tr>
<tr class="separator:aec1872008530bb84d39166c7b71642e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac687dc476e43a3f176e2211716f30594"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#ac687dc476e43a3f176e2211716f30594">CAN_bypass_filter_accept_all_msgs</a> (void)</td></tr>
<tr class="separator:ac687dc476e43a3f176e2211716f30594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498bc7e462028ced7dcfde20eb3dddb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a498bc7e462028ced7dcfde20eb3dddb9">CAN_fullcan_add_entry</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can, can_std_id_t id1, can_std_id_t id2)</td></tr>
<tr class="separator:a498bc7e462028ced7dcfde20eb3dddb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f952dda1eba7495cb922c168d5dfd3b"><td class="memItemLeft" align="right" valign="top">can_fullcan_msg_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a0f952dda1eba7495cb922c168d5dfd3b">CAN_fullcan_get_entry_ptr</a> (can_std_id_t fc_id)</td></tr>
<tr class="separator:a0f952dda1eba7495cb922c168d5dfd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a564a174fbed82486e0a4d5a1fce94a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a4a564a174fbed82486e0a4d5a1fce94a">CAN_fullcan_read_msg_copy</a> (can_fullcan_msg_t *fc_msg_ptr, can_fullcan_msg_t *msg_copy_ptr)</td></tr>
<tr class="separator:a4a564a174fbed82486e0a4d5a1fce94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d6c7ddef6d04f48e307845726156d2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#af6d6c7ddef6d04f48e307845726156d2">CAN_fullcan_get_num_entries</a> (void)</td></tr>
<tr class="separator:af6d6c7ddef6d04f48e307845726156d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86011b37f4fb306df4a79a962a39e86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#af86011b37f4fb306df4a79a962a39e86">CAN_setup_filter</a> (const can_std_id_t *std_id_list, uint16_t sid_cnt, const <a class="el" href="../../d9/da8/structcan__std__grp__id__t.html">can_std_grp_id_t</a> *std_group_id_list, uint16_t sgp_cnt, const can_ext_id_t *ext_id_list, uint16_t eid_cnt, const <a class="el" href="../../d4/d39/structcan__ext__grp__id__t.html">can_ext_grp_id_t</a> *ext_group_id_list, uint16_t egp_cnt)</td></tr>
<tr class="separator:af86011b37f4fb306df4a79a962a39e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5d99e1adce27fe7d0dc61885cf60b109"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a5d99e1adce27fe7d0dc61885cf60b109">CAN_is_bus_off</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can)</td></tr>
<tr class="separator:a5d99e1adce27fe7d0dc61885cf60b109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ace748a245e229fd9fa3733b6647e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a33ace748a245e229fd9fa3733b6647e7">CAN_reset_bus</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can)</td></tr>
<tr class="separator:a33ace748a245e229fd9fa3733b6647e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab234b183927d70dcf2c931ce4371e66d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#ab234b183927d70dcf2c931ce4371e66d">CAN_get_rx_watermark</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can)</td></tr>
<tr class="memdesc:ab234b183927d70dcf2c931ce4371e66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">RX FreeRTOS Queue watermark.  <a href="#ab234b183927d70dcf2c931ce4371e66d">More...</a><br /></td></tr>
<tr class="separator:ab234b183927d70dcf2c931ce4371e66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815c96adb4e5754e999ce4ce702456b4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a815c96adb4e5754e999ce4ce702456b4">CAN_get_tx_watermark</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can)</td></tr>
<tr class="memdesc:a815c96adb4e5754e999ce4ce702456b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX FreeRTOS Queue watermark.  <a href="#a815c96adb4e5754e999ce4ce702456b4">More...</a><br /></td></tr>
<tr class="separator:a815c96adb4e5754e999ce4ce702456b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa506373e0e6f9f6e3d46af9a9ebc3c53"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#aa506373e0e6f9f6e3d46af9a9ebc3c53">CAN_get_tx_count</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can)</td></tr>
<tr class="memdesc:aa506373e0e6f9f6e3d46af9a9ebc3c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of messages written to the CAN HW.  <a href="#aa506373e0e6f9f6e3d46af9a9ebc3c53">More...</a><br /></td></tr>
<tr class="separator:aa506373e0e6f9f6e3d46af9a9ebc3c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2b93db51a964df358a8611d850a2d2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#aea2b93db51a964df358a8611d850a2d2">CAN_get_rx_count</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can)</td></tr>
<tr class="memdesc:aea2b93db51a964df358a8611d850a2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of messages successfully queued from CAN interrupt (not including dropped)  <a href="#aea2b93db51a964df358a8611d850a2d2">More...</a><br /></td></tr>
<tr class="separator:aea2b93db51a964df358a8611d850a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aca546899ecc207b8b3c78fa9dcd8c5a3"><td class="memItemLeft" align="right" valign="top">can_std_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#aca546899ecc207b8b3c78fa9dcd8c5a3">CAN_gen_sid</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can, uint16_t id)</td></tr>
<tr class="separator:aca546899ecc207b8b3c78fa9dcd8c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9156b784b67997345a29aa52d33838"><td class="memItemLeft" align="right" valign="top">can_ext_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/can_8h.html#a5d9156b784b67997345a29aa52d33838">CAN_gen_eid</a> (<a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a> can, uint32_t id)</td></tr>
<tr class="separator:a5d9156b784b67997345a29aa52d33838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a simple CAN driver that optionally utilizes the FullCAN capability. FullCAN is hardware filtering of the CAN messages and the configured messages are stored directly into the CAN RAM (separate 2K RAM) without CPU intervention.</p>
<p>FullCAN feature summary :</p><ul>
<li>Messages go straight into dedicated RAM, SW never needs to be interrupted</li>
<li>Each FullCAN entry can generate an interrupt (up to 64 messages)</li>
<li>FullCAN entry can only be 11-bit NOT 29-bit type.</li>
<li>Note that FullCAN is for BOTH CANs. If you wish to have separate message reads of individual CANs, you can enable non FullCAN filters because the implementation provides queues of separate CAN channels.</li>
</ul>
<p>When the CAN bus is initialized, we initially configure it to not accept any messages until filtering or bypass option is used. For the filtering, in addition to the FullCAN, you can configure explicit 11-bit and 29-bit IDs (including groups) and only these messages will be accepted.</p>
<p>Note that if you send a message, and no other node acknowledges the message sent, then the CAN BUS may enter "Bus off" state due to error(s). You must correct this situation and reset the CAN BUS. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a70166a12001edeee7860a1257037be44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* can_void_func_t) (uint32_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CAN function pointer type The 32-bit parameter is the value of the ICR register of CANbus </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ac94be130a7809f09346c1b89b3d44bdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CAN BUS type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac94be130a7809f09346c1b89b3d44bdda5d6d98ee073edc2321bb51b10db12888"></a>can1&#160;</td><td class="fielddoc">
<p>CAN #1. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac94be130a7809f09346c1b89b3d44bdda23699735f0e1c354cceae24f5c2cd9fe"></a>can2&#160;</td><td class="fielddoc">
<p>CAN #2. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac94be130a7809f09346c1b89b3d44bddab38d40c499b095adf4aca181ecb10d59"></a>can_max&#160;</td><td class="fielddoc">
<p>Do not use or change. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac687dc476e43a3f176e2211716f30594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_bypass_filter_accept_all_msgs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables CAN bypass mode to accept all messages on the bus. Either CAN filters need to be setup or this method should be called to accept CAN messages otherwise no messages will be capture at the CAN HW registers.</p>
<dl class="section note"><dt>Note</dt><dd>The filter is for BOTH CANs </dd></dl>

</div>
</div>
<a class="anchor" id="a498bc7e462028ced7dcfde20eb3dddb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_fullcan_add_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">can_std_id_t&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">can_std_id_t&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds two FullCAN entries to the acceptance filter and enables the FullCAN reception. The entries must be added in groups of 2. If the second entry is not needed, simply pass 0xFFFF to <a class="el" href="../../d7/da8/can_8h.html#aca546899ecc207b8b3c78fa9dcd8c5a3">CAN_gen_sid()</a> to generate a disabled entry.</p>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only 11-bit IDs can use FullCAN.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This must be done BEFORE setting up other filters using <a class="el" href="../../d7/da8/can_8h.html#af86011b37f4fb306df4a79a962a39e86">CAN_setup_filter()</a> </dd>
<dd>
CAN BUS should not be enabled to do this because the CAN Filter is put to OFF mode while the entry is added.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>TO DO: Enabling fc_intr bit (FullCAN interrupts) is not yet supported </dd></dl>

</div>
</div>
<a class="anchor" id="a0f952dda1eba7495cb922c168d5dfd3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">can_fullcan_msg_t* CAN_fullcan_get_entry_ptr </td>
          <td>(</td>
          <td class="paramtype">can_std_id_t&#160;</td>
          <td class="paramname"><em>fc_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Once all the FulLCAN entries are added, and CAN filters are setup, you can get the pointer in memory where the actual CAN message (FullCAN entry) is stored in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fc_id</td><td>The FullCAN entry originally passed to <a class="el" href="../../d7/da8/can_8h.html#a498bc7e462028ced7dcfde20eb3dddb9">CAN_fullcan_add_entry()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6d6c7ddef6d04f48e307845726156d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CAN_fullcan_get_num_entries </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of FullCAN entries being used </dd></dl>

</div>
</div>
<a class="anchor" id="a4a564a174fbed82486e0a4d5a1fce94a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_fullcan_read_msg_copy </td>
          <td>(</td>
          <td class="paramtype">can_fullcan_msg_t *&#160;</td>
          <td class="paramname"><em>fc_msg_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">can_fullcan_msg_t *&#160;</td>
          <td class="paramname"><em>msg_copy_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FullCAN entries may update at any time by the HW, so this method provides a means to safely read the copy of the FullCAN message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_copy_ptr</td><td>The same message returned from <a class="el" href="../../d7/da8/can_8h.html#a0f952dda1eba7495cb922c168d5dfd3b">CAN_fullcan_get_entry_ptr()</a> </td></tr>
    <tr><td class="paramname">fc_msg_ptr</td><td>The copy of the message you wish to read the data to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a NEW message has been captured since the last call to this method. false if HW did not receive a new message </dd></dl>

</div>
</div>
<a class="anchor" id="a5d9156b784b67997345a29aa52d33838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">can_ext_id_t CAN_gen_eid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aca546899ecc207b8b3c78fa9dcd8c5a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">can_std_id_t CAN_gen_sid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate and return the ID used to create the standard and extended id list member. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d7/da8/can_8h.html#af86011b37f4fb306df4a79a962a39e86">CAN_setup_filter()</a></dd></dl>
<p>To generate a disabled slot, just pass 0xFFFF (id) as the message id, which will disable the message. This is used to generate an empty slot to make an even number of entries as required by the standard id filter. </p>

</div>
</div>
<a class="anchor" id="aea2b93db51a964df358a8611d850a2d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CAN_get_rx_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of messages successfully queued from CAN interrupt (not including dropped) </p>

</div>
</div>
<a class="anchor" id="aec1872008530bb84d39166c7b71642e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CAN_get_rx_dropped_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of CAN messages dropped Messages can be dropped out either if the receive queue is too small, or if there is no consumer or task that dequeues the received messages quickly enough from the <a class="el" href="../../d7/da8/can_8h.html#a6f27267c493bfefca258bb24d5c17704">CAN_rx()</a> API </dd></dl>

</div>
</div>
<a class="anchor" id="ab234b183927d70dcf2c931ce4371e66d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CAN_get_rx_watermark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RX FreeRTOS Queue watermark. </p>
<p>Watermark and counter API </p>

</div>
</div>
<a class="anchor" id="aa506373e0e6f9f6e3d46af9a9ebc3c53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CAN_get_tx_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of messages written to the CAN HW. </p>

</div>
</div>
<a class="anchor" id="a815c96adb4e5754e999ce4ce702456b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CAN_get_tx_watermark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TX FreeRTOS Queue watermark. </p>

</div>
</div>
<a class="anchor" id="a0e186b576e535b32e6a884a89a4dcb0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate_kbps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxq_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txq_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#a70166a12001edeee7860a1257037be44">can_void_func_t</a>&#160;</td>
          <td class="paramname"><em>bus_off_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#a70166a12001edeee7860a1257037be44">can_void_func_t</a>&#160;</td>
          <td class="paramname"><em>data_ovr_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the CAN controller with the given baud-rate. </p><dl class="section warning"><dt>Warning</dt><dd>This leaves the CAN BUS DISABLED!!! The next steps are :<ul>
<li>Optionally, configure the FullCAN. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d7/da8/can_8h.html#a498bc7e462028ced7dcfde20eb3dddb9">CAN_fullcan_add_entry()</a><ul>
<li>Optionally, configure CAN filters. </li>
</ul>
</dd>
<dd>
<a class="el" href="../../d7/da8/can_8h.html#af86011b37f4fb306df4a79a962a39e86">CAN_setup_filter()</a><ul>
<li>If filters are not configured, and you wish to accept all messages, call <a class="el" href="../../d7/da8/can_8h.html#ac687dc476e43a3f176e2211716f30594">CAN_bypass_filter_accept_all_msgs()</a></li>
<li>Call <a class="el" href="../../d7/da8/can_8h.html#a33ace748a245e229fd9fa3733b6647e7">CAN_reset_bus()</a> to enable the CAN BUS</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can</td><td>The can bus type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd" title="The CAN BUS type. ">can_t</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate_kbps</td><td>The CAN Bus baud-rate, such as 100, 250, 500, 1000 Precise, external crystal should be used for higher than 100kbps </td></tr>
    <tr><td class="paramname">rxq_size</td><td>The size of the received messages queue </td></tr>
    <tr><td class="paramname">txq_size</td><td>The size of the transmit messages queue</td></tr>
    <tr><td class="paramname">bus_off_cb</td><td>The callback function when CAN BUS enters BUS error state </td></tr>
    <tr><td class="paramname">data_ovr_cb</td><td>The callback function when CAN BUS encounters data-overrun </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Both bus_off_cb and data_ovr_cb are optional. BUS overrun callback should be used because if user doesn't correct this, the CAN BUS will never recover once the BUS error state is entered.</dd>
<dd>
Each CAN BUS has separate receive and transmit queues </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The CAN bus is initialized, and by default, no messages are accepted until CAN filter is setup, and <a class="el" href="../../d7/da8/can_8h.html#a33ace748a245e229fd9fa3733b6647e7">CAN_reset_bus()</a> is called. </dd></dl>
<p>About the AFMR register : B0 B1 Filter Mode | AccOff bit | AccBP bit | CAN Rx interrupt Off Mode 1 0 No messages accepted Bypass Mode X 1 All messages accepted FullCAN 0 0 HW acceptance filtering</p>

</div>
</div>
<a class="anchor" id="a5d99e1adce27fe7d0dc61885cf60b109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_is_bus_off </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CAN Bus Error and Reset API If the CAN BUS encounters error(s), it may turn off, in which case no more transmissions will take place. This must be corrected by the user. </p>

</div>
</div>
<a class="anchor" id="a33ace748a245e229fd9fa3733b6647e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_reset_bus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6f27267c493bfefca258bb24d5c17704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">can_msg_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive a message of the given CAN BUS. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can</td><td>The can bus type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd" title="The CAN BUS type. ">can_t</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The CAN message </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>If FreeRTOS is running, the task will block until a message arrives. Otherwise we will poll and wait this timeout to receive a message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if message was captured within the given timeout. </dd></dl>

</div>
</div>
<a class="anchor" id="af86011b37f4fb306df4a79a962a39e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_setup_filter </td>
          <td>(</td>
          <td class="paramtype">const can_std_id_t *&#160;</td>
          <td class="paramname"><em>std_id_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sid_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/da8/structcan__std__grp__id__t.html">can_std_grp_id_t</a> *&#160;</td>
          <td class="paramname"><em>std_group_id_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sgp_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const can_ext_id_t *&#160;</td>
          <td class="paramname"><em>ext_id_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eid_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d39/structcan__ext__grp__id__t.html">can_ext_grp_id_t</a> *&#160;</td>
          <td class="paramname"><em>ext_group_id_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>egp_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable CAN filter for BOTH CANs; hardware doesn't allow to enable for just ONE CAN controller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std_id_list</td><td>List of 11-bit IDs to generate an ACK for (can be NULL) </td></tr>
    <tr><td class="paramname">sid_cnt</td><td>The size of the can_std_id_t array</td></tr>
    <tr><td class="paramname">std_group_id_list</td><td>List of 11-bit ID groups to generate an ACK for (can be NULL) </td></tr>
    <tr><td class="paramname">sgp_cnt</td><td>The size of the <a class="el" href="../../d9/da8/structcan__std__grp__id__t.html">can_std_grp_id_t</a> array</td></tr>
    <tr><td class="paramname">ext_id_list</td><td>List of 29-bit IDs to generate an ACK for (can be NULL) </td></tr>
    <tr><td class="paramname">eid_cnt</td><td>The size of the can_ext_id_t array</td></tr>
    <tr><td class="paramname">ext_group_id_list</td><td>List of 29-bit ID groups to generate an ACK for (can be NULL) </td></tr>
    <tr><td class="paramname">egp_cnt</td><td>The size of the <a class="el" href="../../d4/d39/structcan__ext__grp__id__t.html">can_ext_grp_id_t</a> array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The list must be in ASCENDING order (lowest first, then highest). The hardware carries out its search taking for granted that the IDs are ordered from lowest to highest. If filters are wrong, CAN ISR will enter a loop and your board will restart (due to watchdog).</dd>
<dd>
CAN BUS should not be enabled to do this because the CAN Filter is put to OFF mode while the entry is added.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The CAN filter must be setup after the CAN controller(s) is initialized. </dd>
<dd>
The size entries is limited to 2K bytes. Each entry size in bytes is :<ul>
<li>can_std_id_t : 2</li>
<li><a class="el" href="../../d9/da8/structcan__std__grp__id__t.html">can_std_grp_id_t</a> : 4</li>
<li>can_ext_id_t : 4</li>
<li><a class="el" href="../../d4/d39/structcan__ext__grp__id__t.html">can_ext_grp_id_t</a> : 8</li>
</ul>
</dd></dl>
<p>Here is sample code that enables HW filtering of selected CAN messages. Note that some messages are for CAN2 while most are for CAN1 </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const can_std_id_t slist[]      = { CAN_gen_sid(can1, 0x100), CAN_gen_sid(can1, 0x110),   // 2 entries</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                                    CAN_gen_sid(can1, 0x120), CAN_gen_sid(can1, 0x130)    // 2 entries</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                                  };</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;const can_std_grp_id_t sglist[] = { {CAN_gen_sid(can1, 0x150), CAN_gen_sid(can1, 0x200)}, // Group 1</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;                                    {CAN_gen_sid(can2, 0x300), CAN_gen_sid(can2, 0x400)}  // Group 2</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                                  };</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;const can_ext_id_t *elist       = NULL; // Not used, so set it to NULL</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;const can_ext_grp_id_t eglist[] = { {CAN_gen_eid(can1, 0x3500), CAN_gen_eid(can1, 0x4500)} }; // Group 1</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;CAN_setup_filter(slist, 4, sglist, 2,</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                 elist, 0, eglist, 1);</div></div><!-- fragment --> <p>Standard ID list and group list need to swapped otherwise setting the wrong filter will make the CAN ISR go into a loop for no apparent reason. It looks like the filter data is motorolla big-endian format. See "configuration example 5" in CAN chapter.</p>

</div>
</div>
<a class="anchor" id="a595ba2fcfcdfff25071aed5a361f4b72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CAN_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd">can_t</a>&#160;</td>
          <td class="paramname"><em>can</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">can_msg_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a CAN message over the CAN BUS </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can</td><td>The can bus type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d7/da8/can_8h.html#ac94be130a7809f09346c1b89b3d44bdd" title="The CAN BUS type. ">can_t</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The CAN message </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>If FreeRTOS is running, the task will block for timeout_ms if HW buffers and the transmit queue is full. If FreeRTOS is not running the timeout is simply, ignored, and false is returned if all three HW buffers are full.</td></tr>
  </table>
  </dd>
</dl>
<p>The transmit queue is only used if all three buffers of the CAN hardware are busy, in which case, the transmission complete interrupt will later send the queued msg. </p><dl class="section return"><dt>Returns</dt><dd>If CAN message was either sent, or queued, true is returned. If all the hardware buffers are full, and the queue is full, then false is returned if timeout occurs waiting for the queue to empty.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;can_msg_t msg;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;msg.msg_id = 0x123;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;msg.frame_fields.is_29bit = 1;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;msg.frame_fields.data_len = 8;       // Send 8 bytes</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;msg.data.qword = 0x1122334455667788; // Write all 8 bytes of data at once</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;CAN_tx(can_1, &amp;msg, portMAX_DELAY);</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
