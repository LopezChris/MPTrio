\hypertarget{mesh_8h}{}\section{/var/www/html/\+S\+J\+S\+U-\/\+D\+E\+V-\/\+Linux/firmware/default/lib/\+L4\+\_\+\+I\+O/wireless/src/mesh.h File Reference}
\label{mesh_8h}\index{/var/www/html/\+S\+J\+S\+U-\/\+D\+E\+V-\/\+Linux/firmware/default/lib/\+L4\+\_\+\+I\+O/wireless/src/mesh.\+h@{/var/www/html/\+S\+J\+S\+U-\/\+D\+E\+V-\/\+Linux/firmware/default/lib/\+L4\+\_\+\+I\+O/wireless/src/mesh.\+h}}


Simple Mesh Network Algorithm.

V\+E\+R\+S\+I\+ON\+:  


{\ttfamily \#include \char`\"{}mesh\+\_\+typedefs.\+h\char`\"{}}\\*
Include dependency graph for mesh.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=302pt]{de/d74/mesh_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d4/db2/mesh_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{mesh_8h_a6f15321e3f9a562db7aa2ef80b3c9678}{mesh\+\_\+init} (const uint8\+\_\+t local\+\_\+node\+\_\+id, const bool is\+\_\+mesh\+\_\+node, const char $\ast$node\+\_\+name, const \hyperlink{structmesh__driver__t}{mesh\+\_\+driver\+\_\+t} driver, const bool discovery)
\item 
bool \hyperlink{mesh_8h_a99477e3755819bb0efed800e004c1146}{mesh\+\_\+set\+\_\+node\+\_\+address} (const uint8\+\_\+t local\+\_\+node\+\_\+id)
\item 
uint8\+\_\+t \hyperlink{mesh_8h_a9408ef3e299e62d09b57f6b123f72b0e}{mesh\+\_\+get\+\_\+node\+\_\+address} (void)
\item 
void \hyperlink{mesh_8h_a4bb50d3a747c90270e7023d8fab5d645}{mesh\+\_\+set\+\_\+retry\+\_\+count} (const uint8\+\_\+t count)
\item 
void \hyperlink{mesh_8h_a03cc4bb7106a1f1b3ee8c69904a38cb2}{mesh\+\_\+service} (void)
\item 
bool \hyperlink{mesh_8h_a9c45fae1c0b0119122ad5900790c28f5}{mesh\+\_\+send} (const uint8\+\_\+t dst, const \hyperlink{mesh__typedefs_8h_a4e50257f904223b4cb6473811f8f709f}{mesh\+\_\+protocol\+\_\+t} type, const void $\ast$p\+Data, const uint8\+\_\+t \hyperlink{startup_8cpp_a77124bd5f7e31e6fffc19f335da0c23f}{len}, const uint8\+\_\+t hop\+\_\+count\+\_\+max)
\item 
bool \hyperlink{mesh_8h_a23bd78e863b4ed4db7609870528ff116}{mesh\+\_\+form\+\_\+pkt} (mesh\+\_\+packet\+\_\+t $\ast$pkt, const uint8\+\_\+t dst, const \hyperlink{mesh__typedefs_8h_a4e50257f904223b4cb6473811f8f709f}{mesh\+\_\+protocol\+\_\+t} type, const uint8\+\_\+t hop\+\_\+count\+\_\+max, uint8\+\_\+t num\+\_\+ptrs,...)
\item 
bool \hyperlink{mesh_8h_a837258fd96147b9e12f56ab4ebc02f0d}{mesh\+\_\+send\+\_\+formed\+\_\+pkt} (mesh\+\_\+packet\+\_\+t $\ast$pkt)
\item 
bool \hyperlink{mesh_8h_ad7abd39828420060487920365fe13a40}{mesh\+\_\+deform\+\_\+pkt} (mesh\+\_\+packet\+\_\+t $\ast$pkt, uint8\+\_\+t num\+\_\+ptrs,...)
\item 
const \hyperlink{structmesh__rte__table__t}{mesh\+\_\+rte\+\_\+table\+\_\+t} $\ast$ \hyperlink{mesh_8h_a8961cdfa52d82bcf723b1d537b649eef}{mesh\+\_\+get\+\_\+routing\+\_\+entry} (const uint8\+\_\+t route\+\_\+num)
\item 
uint8\+\_\+t \hyperlink{mesh_8h_aa6f5a4bee631d6a5c68576b6362ea31d}{mesh\+\_\+get\+\_\+num\+\_\+routing\+\_\+entries} (void)
\item 
bool \hyperlink{mesh_8h_ad4e201c5da747f7b9b3286fd0cea3903}{mesh\+\_\+is\+\_\+route\+\_\+known} (const uint8\+\_\+t addr)
\item 
uint8\+\_\+t \hyperlink{mesh_8h_afeed880a57b13c988fcf1ebba46c0041}{mesh\+\_\+get\+\_\+pnd\+\_\+pkt\+\_\+count} (void)
\item 
uint32\+\_\+t \hyperlink{mesh_8h_ab5d966e151a221d83129fdf544803f8c}{mesh\+\_\+get\+\_\+expected\+\_\+ack\+\_\+time} (uint8\+\_\+t node\+\_\+addr)
\item 
uint32\+\_\+t \hyperlink{mesh_8h_a69a9dcdc4b83c7afd65179f5fad6c501}{mesh\+\_\+get\+\_\+max\+\_\+timeout\+\_\+before\+\_\+packet\+\_\+fails} (uint8\+\_\+t node\+\_\+addr)
\item 
mesh\+\_\+stats\+\_\+t \hyperlink{mesh_8h_a7a49ced8179b340e1a68c6c8b6dbe3e3}{mesh\+\_\+get\+\_\+stats} (void)
\end{DoxyCompactItemize}
{\bf }\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{mesh__typedefs_8h_a127c488ccfa1bb458510e631aea7b519}{mesh\+\_\+error\+\_\+mask\+\_\+t} \hyperlink{mesh_8h_a09f896f0dd65fe97af63048ffbb80d39}{mesh\+\_\+get\+\_\+error\+\_\+mask} (void)
\item 
void \hyperlink{mesh_8h_a6f3443af5943ab766d146b1cf85d8538}{mesh\+\_\+reset\+\_\+error\+\_\+mask} (void)
\begin{DoxyCompactList}\small\item\em Resets the error mask to zero. \end{DoxyCompactList}\end{DoxyCompactItemize}



\subsection{Detailed Description}
Simple Mesh Network Algorithm.

V\+E\+R\+S\+I\+ON\+: 

\begin{DoxySeeAlso}{See also}
\hyperlink{mesh__config_8h}{mesh\+\_\+config.\+h} version and change history information.
\end{DoxySeeAlso}
\begin{DoxyParagraph}{Simple Mesh Algorithm for low powered radios.}
This library has small footprint with minimal code and R\+AM requirements. Each node can be a repeater node, and contains its own routing table.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Types of Packets}

\begin{DoxyItemize}
\item N\+A\+CK \+: \char`\"{}\+Fire-\/and-\/\+Forget\char`\"{} packet, no acknowledgment from receiver.
\item A\+CK \+: Receiver will auto-\/acknowledge, and packet is retransmitted if A\+CK not received.
\item Broadcast, and Application A\+CK
\end{DoxyItemize}
\end{DoxyParagraph}
\begin{DoxyParagraph}{Example Initialization Code\+:}
Assuming the radio functions and application receive function is provided, init() code is simple \+:
\end{DoxyParagraph}

\begin{DoxyCode}
 \textcolor{comment}{// Example mesh callback function :}
 \textcolor{keywordtype}{int} my\_radio\_init(\textcolor{keywordtype}{void} *data, \textcolor{keywordtype}{int} len)
 \{
     \textcolor{comment}{// Initialize your radio chip.}
 \}

 \textcolor{comment}{// Example timer function}
 \textcolor{keywordtype}{int} my\_timer\_get(\textcolor{keywordtype}{void} *pData, \textcolor{keywordtype}{int} len) \{
     \textcolor{keyword}{const} \textcolor{keywordtype}{char} ok = (\textcolor{keyword}{sizeof}(uint32\_t) == len);           \textcolor{comment}{// Size passed in will be uint32\_t}
     \textcolor{keyword}{const} uint32\_t timerValueMs = your\_sys\_timer\_get();  \textcolor{comment}{// Get your system timer value}
     \textcolor{keywordflow}{if} (ok) \{
         uint32\_t *timer = (uint32\_t*)pData;
         *timer = timerValueMs;
     \}
     \textcolor{keywordflow}{return} \hyperlink{trace_2readme_8txt_ab1dec86efb716110c1bbcfec4dda55f1}{ok};
 \}

Mesh\_DriverStruct driver;
driver.radio\_init = my\_radio\_init;
driver.radio\_send = my\_radio\_send;
driver.radio\_recv = my\_radio\_recv;
driver.app\_recv   = my\_app\_recv;
driver.get\_timer  = my\_timer\_get;

\textcolor{keywordtype}{char} my\_node\_id = 0x10;
\hyperlink{mesh_8c_ad31343f85f5d8ecf0f347b210f7eb299}{mesh\_init}(my\_node\_id, \textcolor{keyword}{true}, &driver, \textcolor{keyword}{true});
\end{DoxyCode}


\begin{DoxyParagraph}{Sample code for a node receiving data \+:}

\begin{DoxyCode}
 \textcolor{comment}{// Global variables}
mesh\_packet\_t packet;
\textcolor{keywordtype}{bool} rx = \textcolor{keyword}{false};

\textcolor{comment}{// Application receive callback}
\textcolor{keywordtype}{int} my\_app\_recv(\textcolor{keywordtype}{void} *data, \textcolor{keywordtype}{int} len)
\{
     memcpy(&packet, data, len);
     rx = \textcolor{keyword}{true};
\}

 \textcolor{comment}{// main loop :}
\textcolor{keywordflow}{while}(1) \{
    \hyperlink{mesh_8c_a03cc4bb7106a1f1b3ee8c69904a38cb2}{mesh\_service}();

    \textcolor{keywordflow}{if}(rx) \{
        rx = \textcolor{keyword}{false};
        \textcolor{keywordflow}{if}(mesh\_is\_ack\_required(&packet)) \{
            mesh\_send\_ack(\textcolor{stringliteral}{"Hello Back"}, 10, &packet);
        \}
    \}
\}
\end{DoxyCode}

\end{DoxyParagraph}
\begin{DoxyWarning}{Warning}
Care needs to be taken for single radio systems when they send out a packet. You don\textquotesingle{}t want the mesh route discovery packet to be repeated at the same time by the nearby nodes because their data will collide and nothing will go through. The radio send function can then be modified with logic similar to \+: 
\begin{DoxyCode}
\textcolor{keywordtype}{char} my\_radio\_send(\textcolor{keywordtype}{char}* pData, \textcolor{keywordtype}{int} len)
\{
  \textcolor{keywordflow}{if} (\hyperlink{mesh_8c_a9408ef3e299e62d09b57f6b123f72b0e}{mesh\_get\_node\_address}() != pkt->nwk.src) \{
    \textcolor{keywordflow}{if} (\hyperlink{mesh__config_8h_a63ca5705e9ee192e6e154cb7b1644252}{MESH\_ZERO\_ADDR} == pkt->mac.dst) \{
        \textcolor{keyword}{const} uint32\_t timeSlotDelayUs = ((rand() % slots) + 1) * pkt\_air\_time\_us;
        \hyperlink{utilities_8c_aa43c73d8be7eb210407d04ce9567d64b}{delay\_us}(timeSlotDelayUs); 
    \}
  \}
\}
\end{DoxyCode}
 
\end{DoxyWarning}


\subsection{Function Documentation}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+deform\+\_\+pkt@{mesh\+\_\+deform\+\_\+pkt}}
\index{mesh\+\_\+deform\+\_\+pkt@{mesh\+\_\+deform\+\_\+pkt}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+deform\+\_\+pkt(mesh\+\_\+packet\+\_\+t $\ast$pkt, uint8\+\_\+t num\+\_\+ptrs,...)}{mesh_deform_pkt(mesh_packet_t *pkt, uint8_t num_ptrs,...)}}]{\setlength{\rightskip}{0pt plus 5cm}bool mesh\+\_\+deform\+\_\+pkt (
\begin{DoxyParamCaption}
\item[{mesh\+\_\+packet\+\_\+t $\ast$}]{pkt, }
\item[{uint8\+\_\+t}]{num\+\_\+ptrs, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_ad7abd39828420060487920365fe13a40}{}\label{mesh_8h_ad7abd39828420060487920365fe13a40}
This does the opposite of \hyperlink{mesh_8h_a23bd78e863b4ed4db7609870528ff116}{mesh\+\_\+form\+\_\+pkt()}. Instead of copying data from the pointers and storing to the packet data, this will copy the data from the packet and store to your pointers. 
\begin{DoxyParams}{Parameters}
{\em pkt} & The mesh packet received. \\
\hline
{\em num\+\_\+ptrs} & The number of pairs of pointers. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if the packet was smaller than the data being asked to store.
\end{DoxyReturn}

\begin{DoxyCode}
1 // Assume we got a packet with a uint32\_t and a float :
2 uint32\_t my\_int = 0;
3 float my\_flt = 0;
4 mesh\_deform\_pkt(&pkt, 2,
5                 &my\_flt, sizeof(my\_flt),
6                 &my\_int, sizeof(my\_int));
\end{DoxyCode}
 \index{mesh.\+h@{mesh.\+h}!mesh\+\_\+form\+\_\+pkt@{mesh\+\_\+form\+\_\+pkt}}
\index{mesh\+\_\+form\+\_\+pkt@{mesh\+\_\+form\+\_\+pkt}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+form\+\_\+pkt(mesh\+\_\+packet\+\_\+t $\ast$pkt, const uint8\+\_\+t dst, const mesh\+\_\+protocol\+\_\+t type, const uint8\+\_\+t hop\+\_\+count\+\_\+max, uint8\+\_\+t num\+\_\+ptrs,...)}{mesh_form_pkt(mesh_packet_t *pkt, const uint8_t dst, const mesh_protocol_t type, const uint8_t hop_count_max, uint8_t num_ptrs,...)}}]{\setlength{\rightskip}{0pt plus 5cm}bool mesh\+\_\+form\+\_\+pkt (
\begin{DoxyParamCaption}
\item[{mesh\+\_\+packet\+\_\+t $\ast$}]{pkt, }
\item[{const uint8\+\_\+t}]{dst, }
\item[{const {\bf mesh\+\_\+protocol\+\_\+t}}]{type, }
\item[{const uint8\+\_\+t}]{hop\+\_\+count\+\_\+max, }
\item[{uint8\+\_\+t}]{num\+\_\+ptrs, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a23bd78e863b4ed4db7609870528ff116}{}\label{mesh_8h_a23bd78e863b4ed4db7609870528ff116}
Form a packet by copying the data from the given pointers as variable arguments. \begin{DoxySeeAlso}{See also}
parameters of \hyperlink{mesh_8h_a9c45fae1c0b0119122ad5900790c28f5}{mesh\+\_\+send()} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em num\+\_\+ptrs} & The number of data pointer pairs; see below. \\
\hline
{\em ...} & The pairs of data pointer and the size; see below. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if packet was formed correctly. Error may be returned if you tried to send too much data that the payload cannot hold. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Once a packet is formed, it should be immediately sent because packet route may change later, so the packet may not make it through. 
\begin{DoxyCode}
1 mesh\_packet\_t pkt;
2 
3 // Copy single NULL string
4 mesh\_form\_pkt(&pkt, 1, mesh\_pkt\_ack, 1, 1, "\(\backslash\)0", 1);
5 
6 // Copy two strings:
7 mesh\_form\_pkt(&pkt, 1, mesh\_pkt\_ack, 1,
8               2,           // Two pairs below
9               "hello", 5,  // First pair's data, and the size
10               "world", 5); // Second pair's data, and the size
11 
12 // Copy three variables (string, int, and float):
13 int my\_int = 123;
14 float my\_flt = 1.23;
15 mesh\_form\_pkt(&pkt, 1, mesh\_pkt\_ack, 1,
16               3,
17               "copyme", 6,
18               &my\_int, sizeof(my\_int),
19               &my\_flt, sizeof(my\_flt));
\end{DoxyCode}
 
\end{DoxyWarning}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+get\+\_\+error\+\_\+mask@{mesh\+\_\+get\+\_\+error\+\_\+mask}}
\index{mesh\+\_\+get\+\_\+error\+\_\+mask@{mesh\+\_\+get\+\_\+error\+\_\+mask}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+get\+\_\+error\+\_\+mask(void)}{mesh_get_error_mask(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mesh\+\_\+error\+\_\+mask\+\_\+t} mesh\+\_\+get\+\_\+error\+\_\+mask (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a09f896f0dd65fe97af63048ffbb80d39}{}\label{mesh_8h_a09f896f0dd65fe97af63048ffbb80d39}
Mesh A\+PI to get error types and reset errors Mesh layer keeps error bit fields during its operation. The error mask can be obtained and masked with mesh\+\_\+error\+\_\+mask\+\_\+t to detect the error type, and it can be reset by this A\+PI. 
\begin{DoxyCode}
1 mesh\_error\_mask\_t err = mesh\_get\_error\_mask();
2 if (e & mesh\_err\_dup\_node) \{
3     // Duplicate node with our address found
4 \}
\end{DoxyCode}
\begin{DoxyReturn}{Returns}
errors encountered during mesh network operation. 
\end{DoxyReturn}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+get\+\_\+expected\+\_\+ack\+\_\+time@{mesh\+\_\+get\+\_\+expected\+\_\+ack\+\_\+time}}
\index{mesh\+\_\+get\+\_\+expected\+\_\+ack\+\_\+time@{mesh\+\_\+get\+\_\+expected\+\_\+ack\+\_\+time}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+get\+\_\+expected\+\_\+ack\+\_\+time(uint8\+\_\+t node\+\_\+addr)}{mesh_get_expected_ack_time(uint8_t node_addr)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t mesh\+\_\+get\+\_\+expected\+\_\+ack\+\_\+time (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{node\+\_\+addr}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_ab5d966e151a221d83129fdf544803f8c}{}\label{mesh_8h_ab5d966e151a221d83129fdf544803f8c}
\begin{DoxyReturn}{Returns}
the expected number of milliseconds it should take for the destination node to send us an A\+CK packet. This is the most ideal time assuming no packet is lost while sending or receiving the A\+CK. If the route is not known, then the timeout returned is based on the assumption that it is M\+E\+S\+H\+\_\+\+R\+T\+E\+\_\+\+D\+I\+S\+C\+O\+V\+E\+R\+Y\+\_\+\+H\+O\+PS (\#define\textquotesingle{}d) hops away. 
\end{DoxyReturn}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+get\+\_\+max\+\_\+timeout\+\_\+before\+\_\+packet\+\_\+fails@{mesh\+\_\+get\+\_\+max\+\_\+timeout\+\_\+before\+\_\+packet\+\_\+fails}}
\index{mesh\+\_\+get\+\_\+max\+\_\+timeout\+\_\+before\+\_\+packet\+\_\+fails@{mesh\+\_\+get\+\_\+max\+\_\+timeout\+\_\+before\+\_\+packet\+\_\+fails}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+get\+\_\+max\+\_\+timeout\+\_\+before\+\_\+packet\+\_\+fails(uint8\+\_\+t node\+\_\+addr)}{mesh_get_max_timeout_before_packet_fails(uint8_t node_addr)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t mesh\+\_\+get\+\_\+max\+\_\+timeout\+\_\+before\+\_\+packet\+\_\+fails (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{node\+\_\+addr}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a69a9dcdc4b83c7afd65179f5fad6c501}{}\label{mesh_8h_a69a9dcdc4b83c7afd65179f5fad6c501}
\begin{DoxyReturn}{Returns}
similar to \hyperlink{mesh_8h_ab5d966e151a221d83129fdf544803f8c}{mesh\+\_\+get\+\_\+expected\+\_\+ack\+\_\+time()}, but the returned value is the max expected timeout after we exhaust our retries. 
\end{DoxyReturn}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+get\+\_\+node\+\_\+address@{mesh\+\_\+get\+\_\+node\+\_\+address}}
\index{mesh\+\_\+get\+\_\+node\+\_\+address@{mesh\+\_\+get\+\_\+node\+\_\+address}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+get\+\_\+node\+\_\+address(void)}{mesh_get_node_address(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t mesh\+\_\+get\+\_\+node\+\_\+address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a9408ef3e299e62d09b57f6b123f72b0e}{}\label{mesh_8h_a9408ef3e299e62d09b57f6b123f72b0e}
\begin{DoxyReturn}{Returns}
our mesh node address. 
\end{DoxyReturn}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+get\+\_\+num\+\_\+routing\+\_\+entries@{mesh\+\_\+get\+\_\+num\+\_\+routing\+\_\+entries}}
\index{mesh\+\_\+get\+\_\+num\+\_\+routing\+\_\+entries@{mesh\+\_\+get\+\_\+num\+\_\+routing\+\_\+entries}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+get\+\_\+num\+\_\+routing\+\_\+entries(void)}{mesh_get_num_routing_entries(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t mesh\+\_\+get\+\_\+num\+\_\+routing\+\_\+entries (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_aa6f5a4bee631d6a5c68576b6362ea31d}{}\label{mesh_8h_aa6f5a4bee631d6a5c68576b6362ea31d}
\begin{DoxyReturn}{Returns}
The number of routing entries this node is maintaining. 
\end{DoxyReturn}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+get\+\_\+pnd\+\_\+pkt\+\_\+count@{mesh\+\_\+get\+\_\+pnd\+\_\+pkt\+\_\+count}}
\index{mesh\+\_\+get\+\_\+pnd\+\_\+pkt\+\_\+count@{mesh\+\_\+get\+\_\+pnd\+\_\+pkt\+\_\+count}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+get\+\_\+pnd\+\_\+pkt\+\_\+count(void)}{mesh_get_pnd_pkt_count(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t mesh\+\_\+get\+\_\+pnd\+\_\+pkt\+\_\+count (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_afeed880a57b13c988fcf1ebba46c0041}{}\label{mesh_8h_afeed880a57b13c988fcf1ebba46c0041}
If there are is no packet received from your radio, and there are not any pending packets, then \hyperlink{mesh_8h_a03cc4bb7106a1f1b3ee8c69904a38cb2}{mesh\+\_\+service()} doesn\textquotesingle{}t have to be called periodically.

\begin{DoxyReturn}{Returns}
The number of packets that are in the pending state, means they are waiting to be acknowledged, or repeated after a timeout. 
\end{DoxyReturn}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+get\+\_\+routing\+\_\+entry@{mesh\+\_\+get\+\_\+routing\+\_\+entry}}
\index{mesh\+\_\+get\+\_\+routing\+\_\+entry@{mesh\+\_\+get\+\_\+routing\+\_\+entry}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+get\+\_\+routing\+\_\+entry(const uint8\+\_\+t route\+\_\+num)}{mesh_get_routing_entry(const uint8_t route_num)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf mesh\+\_\+rte\+\_\+table\+\_\+t}$\ast$ mesh\+\_\+get\+\_\+routing\+\_\+entry (
\begin{DoxyParamCaption}
\item[{const uint8\+\_\+t}]{route\+\_\+num}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a8961cdfa52d82bcf723b1d537b649eef}{}\label{mesh_8h_a8961cdfa52d82bcf723b1d537b649eef}
Allows user to query all the routing entries. 
\begin{DoxyParams}{Parameters}
{\em route\+\_\+num} & The route number to query \+: 0 -\/ (N-\/1) When N\+U\+LL is returned, no more route exists. If Non-\/\+N\+U\+LL entry is returned, user can look at destination, the route to next destination, and number of hops it is away. \\
\hline
\end{DoxyParams}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+get\+\_\+stats@{mesh\+\_\+get\+\_\+stats}}
\index{mesh\+\_\+get\+\_\+stats@{mesh\+\_\+get\+\_\+stats}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+get\+\_\+stats(void)}{mesh_get_stats(void)}}]{\setlength{\rightskip}{0pt plus 5cm}mesh\+\_\+stats\+\_\+t mesh\+\_\+get\+\_\+stats (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a7a49ced8179b340e1a68c6c8b6dbe3e3}{}\label{mesh_8h_a7a49ced8179b340e1a68c6c8b6dbe3e3}
\begin{DoxyReturn}{Returns}
The mesh network statistics structure. 
\end{DoxyReturn}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+init@{mesh\+\_\+init}}
\index{mesh\+\_\+init@{mesh\+\_\+init}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+init(const uint8\+\_\+t local\+\_\+node\+\_\+id, const bool is\+\_\+mesh\+\_\+node, const char $\ast$node\+\_\+name, const mesh\+\_\+driver\+\_\+t driver, const bool discovery)}{mesh_init(const uint8_t local_node_id, const bool is_mesh_node, const char *node_name, const mesh_driver_t driver, const bool discovery)}}]{\setlength{\rightskip}{0pt plus 5cm}bool mesh\+\_\+init (
\begin{DoxyParamCaption}
\item[{const uint8\+\_\+t}]{local\+\_\+node\+\_\+id, }
\item[{const bool}]{is\+\_\+mesh\+\_\+node, }
\item[{const char $\ast$}]{node\+\_\+name, }
\item[{const {\bf mesh\+\_\+driver\+\_\+t}}]{driver, }
\item[{const bool}]{discovery}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a6f15321e3f9a562db7aa2ef80b3c9678}{}\label{mesh_8h_a6f15321e3f9a562db7aa2ef80b3c9678}
Initializes the Mesh Network. 
\begin{DoxyParams}{Parameters}
{\em local\+\_\+node\+\_\+id} & Node ID of your local node. \\
\hline
{\em is\+\_\+mesh\+\_\+node} & true, if this node can participate in Mesh to repeat packets. \\
\hline
{\em node\+\_\+name} & Node name, maximum as large as a payload. \\
\hline
{\em driver} & The structure of the radio driver. \\
\hline
{\em discovery} & If true, then a broadcast message with data\+: \char`\"{}\+Hello\textbackslash{}n\char`\"{} is sent to each node within 3 hops away for discovery and route update purpose. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Unless changed otherwise, the retry count contains default value; 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{mesh_8h_a4bb50d3a747c90270e7023d8fab5d645}{mesh\+\_\+set\+\_\+retry\+\_\+count()} 
\end{DoxySeeAlso}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+is\+\_\+route\+\_\+known@{mesh\+\_\+is\+\_\+route\+\_\+known}}
\index{mesh\+\_\+is\+\_\+route\+\_\+known@{mesh\+\_\+is\+\_\+route\+\_\+known}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+is\+\_\+route\+\_\+known(const uint8\+\_\+t addr)}{mesh_is_route_known(const uint8_t addr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool mesh\+\_\+is\+\_\+route\+\_\+known (
\begin{DoxyParamCaption}
\item[{const uint8\+\_\+t}]{addr}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_ad4e201c5da747f7b9b3286fd0cea3903}{}\label{mesh_8h_ad4e201c5da747f7b9b3286fd0cea3903}
\begin{DoxyReturn}{Returns}
true if our routing table contains the route for the given destination address. 
\end{DoxyReturn}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+reset\+\_\+error\+\_\+mask@{mesh\+\_\+reset\+\_\+error\+\_\+mask}}
\index{mesh\+\_\+reset\+\_\+error\+\_\+mask@{mesh\+\_\+reset\+\_\+error\+\_\+mask}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+reset\+\_\+error\+\_\+mask(void)}{mesh_reset_error_mask(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void mesh\+\_\+reset\+\_\+error\+\_\+mask (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a6f3443af5943ab766d146b1cf85d8538}{}\label{mesh_8h_a6f3443af5943ab766d146b1cf85d8538}


Resets the error mask to zero. 

\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+send@{mesh\+\_\+send}}
\index{mesh\+\_\+send@{mesh\+\_\+send}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+send(const uint8\+\_\+t dst, const mesh\+\_\+protocol\+\_\+t type, const void $\ast$p\+Data, const uint8\+\_\+t len, const uint8\+\_\+t hop\+\_\+count\+\_\+max)}{mesh_send(const uint8_t dst, const mesh_protocol_t type, const void *pData, const uint8_t len, const uint8_t hop_count_max)}}]{\setlength{\rightskip}{0pt plus 5cm}bool mesh\+\_\+send (
\begin{DoxyParamCaption}
\item[{const uint8\+\_\+t}]{dst, }
\item[{const {\bf mesh\+\_\+protocol\+\_\+t}}]{type, }
\item[{const void $\ast$}]{p\+Data, }
\item[{const uint8\+\_\+t}]{len, }
\item[{const uint8\+\_\+t}]{hop\+\_\+count\+\_\+max}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a9c45fae1c0b0119122ad5900790c28f5}{}\label{mesh_8h_a9c45fae1c0b0119122ad5900790c28f5}
Sends a new packet. 
\begin{DoxyParams}{Parameters}
{\em dst} & The destination address to send data to. \\
\hline
{\em type} & The type of packet\+: ack, nack, app-\/ack \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{mesh__typedefs_8h_a4e50257f904223b4cb6473811f8f709f}{mesh\+\_\+protocol\+\_\+t} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em p\+Data} & The pointer to the data to send. \\
\hline
{\em len} & The length of the data to send. \\
\hline
{\em hop\+\_\+count\+\_\+max} & See the 3 use cases below \+:
\begin{DoxyItemize}
\item If this is a broadcast message, this controls the max hops packet can take.
\item If the route is known, then this parameter will not have any effect.
\item If the route is unknown, then this controls how far the packet can travel to search for our destined node. You can pass M\+E\+S\+H\+\_\+\+H\+O\+P\+\_\+\+C\+O\+U\+N\+T\+\_\+\+M\+AX if you want the mesh algorithm to figure it out at the cost of utilizing the network a little more and decreasing its efficiency.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the packet was sent successfully 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This function S\+H\+O\+U\+LD N\+OT be used to send an A\+CK back because infinite loop of back-\/and-\/forth A\+C\+Ks may occur. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
mesh\+\_\+send\+\_\+ack() 
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
This method and \hyperlink{mesh_8h_a03cc4bb7106a1f1b3ee8c69904a38cb2}{mesh\+\_\+service()} can be called from different threads because \hyperlink{mesh_8h_a03cc4bb7106a1f1b3ee8c69904a38cb2}{mesh\+\_\+service()} will skip its execution if we are inside a critical section. 
\end{DoxyNote}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+send\+\_\+formed\+\_\+pkt@{mesh\+\_\+send\+\_\+formed\+\_\+pkt}}
\index{mesh\+\_\+send\+\_\+formed\+\_\+pkt@{mesh\+\_\+send\+\_\+formed\+\_\+pkt}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+send\+\_\+formed\+\_\+pkt(mesh\+\_\+packet\+\_\+t $\ast$pkt)}{mesh_send_formed_pkt(mesh_packet_t *pkt)}}]{\setlength{\rightskip}{0pt plus 5cm}bool mesh\+\_\+send\+\_\+formed\+\_\+pkt (
\begin{DoxyParamCaption}
\item[{mesh\+\_\+packet\+\_\+t $\ast$}]{pkt}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a837258fd96147b9e12f56ab4ebc02f0d}{}\label{mesh_8h_a837258fd96147b9e12f56ab4ebc02f0d}
Send a packet that is already formed. 
\begin{DoxyParams}{Parameters}
{\em pkt} & The packet pointer formed by \hyperlink{mesh_8h_a23bd78e863b4ed4db7609870528ff116}{mesh\+\_\+form\+\_\+pkt()}. \\
\hline
\end{DoxyParams}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+service@{mesh\+\_\+service}}
\index{mesh\+\_\+service@{mesh\+\_\+service}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+service(void)}{mesh_service(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void mesh\+\_\+service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a03cc4bb7106a1f1b3ee8c69904a38cb2}{}\label{mesh_8h_a03cc4bb7106a1f1b3ee8c69904a38cb2}
This method should be called periodically. This method gets the radio data, and runs the mesh algorithm. When a packet is received for you, the app\+\_\+recv() call-\/back will be called. \begin{DoxyNote}{Note}
When N1 sends a packet to 4 nodes it can transmit to, all four nodes will repeat the packet if the route is unknown, so we need these nodes to discard the packets they repeat to each other. However, when the origin node doesn\textquotesingle{}t get an A\+CK back, it will r-\/esend the packet with the retries\+\_\+rem decremented, such that all these nodes can repeat the packet instead of throwing it away. The destined node needs to only send data to application layer if packet is not a duplicate, however, for every re-\/sent packet, it needs to A\+CK back the packet.
\end{DoxyNote}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+set\+\_\+node\+\_\+address@{mesh\+\_\+set\+\_\+node\+\_\+address}}
\index{mesh\+\_\+set\+\_\+node\+\_\+address@{mesh\+\_\+set\+\_\+node\+\_\+address}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+set\+\_\+node\+\_\+address(const uint8\+\_\+t local\+\_\+node\+\_\+id)}{mesh_set_node_address(const uint8_t local_node_id)}}]{\setlength{\rightskip}{0pt plus 5cm}bool mesh\+\_\+set\+\_\+node\+\_\+address (
\begin{DoxyParamCaption}
\item[{const uint8\+\_\+t}]{local\+\_\+node\+\_\+id}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a99477e3755819bb0efed800e004c1146}{}\label{mesh_8h_a99477e3755819bb0efed800e004c1146}
This method allows to change the node address after \hyperlink{mesh_8h_a6f15321e3f9a562db7aa2ef80b3c9678}{mesh\+\_\+init()} has been called. 
\begin{DoxyParams}{Parameters}
{\em local\+\_\+node\+\_\+id} & Node ID of your local node. \\
\hline
\end{DoxyParams}
\index{mesh.\+h@{mesh.\+h}!mesh\+\_\+set\+\_\+retry\+\_\+count@{mesh\+\_\+set\+\_\+retry\+\_\+count}}
\index{mesh\+\_\+set\+\_\+retry\+\_\+count@{mesh\+\_\+set\+\_\+retry\+\_\+count}!mesh.\+h@{mesh.\+h}}
\subsubsection[{\texorpdfstring{mesh\+\_\+set\+\_\+retry\+\_\+count(const uint8\+\_\+t count)}{mesh_set_retry_count(const uint8_t count)}}]{\setlength{\rightskip}{0pt plus 5cm}void mesh\+\_\+set\+\_\+retry\+\_\+count (
\begin{DoxyParamCaption}
\item[{const uint8\+\_\+t}]{count}
\end{DoxyParamCaption}
)}\hypertarget{mesh_8h_a4bb50d3a747c90270e7023d8fab5d645}{}\label{mesh_8h_a4bb50d3a747c90270e7023d8fab5d645}

\begin{DoxyParams}{Parameters}
{\em count} & Number of retries used for A\+CK packet if A\+CK not received; see note below. Max value is M\+E\+S\+H\+\_\+\+R\+E\+T\+R\+Y\+\_\+\+C\+O\+U\+N\+T\+\_\+\+M\+AX. Optimal value is 2 (default unless changed).\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The retries apply if routes do not change but the actual retry count may be higher if nodes change routes frequency. For example, if retries are set to 2, and a node N1 sends packet to N3 through N2, then the packet may be sent 6 times\+:
\begin{DoxyItemize}
\item Send original packet, if no A\+CK, then re-\/send 2 more times.
\item Remove N3 route through N2 and re-\/send original packet to discover new route.
\item Re-\/send packet 2 more times if A\+CK still not received. 
\end{DoxyItemize}
\end{DoxyNote}
