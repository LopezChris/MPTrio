\hypertarget{wireless_8c}{}\section{/var/www/html/\+S\+J\+S\+U-\/\+D\+E\+V-\/\+Linux/firmware/default/lib/\+L4\+\_\+\+I\+O/wireless/src/wireless.c File Reference}
\label{wireless_8c}\index{/var/www/html/\+S\+J\+S\+U-\/\+D\+E\+V-\/\+Linux/firmware/default/lib/\+L4\+\_\+\+I\+O/wireless/src/wireless.\+c@{/var/www/html/\+S\+J\+S\+U-\/\+D\+E\+V-\/\+Linux/firmware/default/lib/\+L4\+\_\+\+I\+O/wireless/src/wireless.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdbool.\+h$>$}\\*
{\ttfamily \#include $<$stdint.\+h$>$}\\*
{\ttfamily \#include \char`\"{}wireless.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}Free\+R\+T\+O\+S.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}queue.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}task.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}semphr.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}mesh.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}nrf24\+L01\+Plus.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}sys\+\_\+config.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}lpc\+\_\+sys.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}eint.\+h\char`\"{}}\\*
Include dependency graph for wireless.\+c\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d4/d39/wireless_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{wireless_8c_a5fa8d063b8e42f0e8c11bf76cbddedd0}{wireless\+\_\+init} (void)
\item 
char \hyperlink{wireless_8c_ab1dd852860f7868cf3cf0df2136aa018}{wireless\+\_\+get\+\_\+rx\+\_\+pkt} (mesh\+\_\+packet\+\_\+t $\ast$pkt, const uint32\+\_\+t timeout\+\_\+ms)
\item 
char \hyperlink{wireless_8c_a21d8ed74e468faa3cbee2fc0f34bc6af}{wireless\+\_\+get\+\_\+ack\+\_\+pkt} (mesh\+\_\+packet\+\_\+t $\ast$pkt, const uint32\+\_\+t timeout\+\_\+ms)
\begin{DoxyCompactList}\small\item\em Same as \hyperlink{wireless_8h_ab1dd852860f7868cf3cf0df2136aa018}{wireless\+\_\+get\+\_\+rx\+\_\+pkt()}, except this will retrieve an A\+CK response. \end{DoxyCompactList}\item 
int \hyperlink{wireless_8c_a522ed8eca41a92227ab2971a90e9b30d}{wireless\+\_\+flush\+\_\+rx} (void)
\item 
void \hyperlink{wireless_8c_a62b57561d26f95a86a1e16d470aa95c0}{wireless\+\_\+service} (void)
\end{DoxyCompactItemize}
{\bf }\par



\subsection{Function Documentation}
\index{wireless.\+c@{wireless.\+c}!wireless\+\_\+flush\+\_\+rx@{wireless\+\_\+flush\+\_\+rx}}
\index{wireless\+\_\+flush\+\_\+rx@{wireless\+\_\+flush\+\_\+rx}!wireless.\+c@{wireless.\+c}}
\subsubsection[{\texorpdfstring{wireless\+\_\+flush\+\_\+rx(void)}{wireless_flush_rx(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int wireless\+\_\+flush\+\_\+rx (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{wireless_8c_a522ed8eca41a92227ab2971a90e9b30d}{}\label{wireless_8c_a522ed8eca41a92227ab2971a90e9b30d}
Flush all received data of mesh (A\+C\+Ks and RX packets) \begin{DoxyReturn}{Returns}
the discarded packet count 
\end{DoxyReturn}
\index{wireless.\+c@{wireless.\+c}!wireless\+\_\+get\+\_\+ack\+\_\+pkt@{wireless\+\_\+get\+\_\+ack\+\_\+pkt}}
\index{wireless\+\_\+get\+\_\+ack\+\_\+pkt@{wireless\+\_\+get\+\_\+ack\+\_\+pkt}!wireless.\+c@{wireless.\+c}}
\subsubsection[{\texorpdfstring{wireless\+\_\+get\+\_\+ack\+\_\+pkt(mesh\+\_\+packet\+\_\+t $\ast$pkt, const uint32\+\_\+t timeout\+\_\+ms)}{wireless_get_ack_pkt(mesh_packet_t *pkt, const uint32_t timeout_ms)}}]{\setlength{\rightskip}{0pt plus 5cm}char wireless\+\_\+get\+\_\+ack\+\_\+pkt (
\begin{DoxyParamCaption}
\item[{mesh\+\_\+packet\+\_\+t $\ast$}]{pkt, }
\item[{const uint32\+\_\+t}]{timeout\+\_\+ms}
\end{DoxyParamCaption}
)}\hypertarget{wireless_8c_a21d8ed74e468faa3cbee2fc0f34bc6af}{}\label{wireless_8c_a21d8ed74e468faa3cbee2fc0f34bc6af}


Same as \hyperlink{wireless_8h_ab1dd852860f7868cf3cf0df2136aa018}{wireless\+\_\+get\+\_\+rx\+\_\+pkt()}, except this will retrieve an A\+CK response. 

\index{wireless.\+c@{wireless.\+c}!wireless\+\_\+get\+\_\+rx\+\_\+pkt@{wireless\+\_\+get\+\_\+rx\+\_\+pkt}}
\index{wireless\+\_\+get\+\_\+rx\+\_\+pkt@{wireless\+\_\+get\+\_\+rx\+\_\+pkt}!wireless.\+c@{wireless.\+c}}
\subsubsection[{\texorpdfstring{wireless\+\_\+get\+\_\+rx\+\_\+pkt(mesh\+\_\+packet\+\_\+t $\ast$pkt, const uint32\+\_\+t timeout\+\_\+ms)}{wireless_get_rx_pkt(mesh_packet_t *pkt, const uint32_t timeout_ms)}}]{\setlength{\rightskip}{0pt plus 5cm}char wireless\+\_\+get\+\_\+rx\+\_\+pkt (
\begin{DoxyParamCaption}
\item[{mesh\+\_\+packet\+\_\+t $\ast$}]{pkt, }
\item[{const uint32\+\_\+t}]{timeout\+\_\+ms}
\end{DoxyParamCaption}
)}\hypertarget{wireless_8c_ab1dd852860f7868cf3cf0df2136aa018}{}\label{wireless_8c_ab1dd852860f7868cf3cf0df2136aa018}
Call this function periodically to get a queued packet. 
\begin{DoxyParams}{Parameters}
{\em timeout\+\_\+ms} & The number of milliseconds to wait for a packet. If Free\+R\+T\+OS is running, then this becomes the queue wait time. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a packet was dequeued, or false if there is no packet.
\end{DoxyReturn}
Here is an example of how to send a packet and ensure the destined node received the data \+: 
\begin{DoxyCode}
1 wireless\_send(destination, mesh\_pkt\_ack, "Hello", 5, 3);
2 mesh\_packet\_t rx;
3 
4 if (wireless\_get\_ack\_pkt(&rx, 100)) \{
5     // We got an ACK, but to be sure it came from the right place, check:
6     //     if(rx.nwk.src == destination)
7 \}
\end{DoxyCode}
 \index{wireless.\+c@{wireless.\+c}!wireless\+\_\+init@{wireless\+\_\+init}}
\index{wireless\+\_\+init@{wireless\+\_\+init}!wireless.\+c@{wireless.\+c}}
\subsubsection[{\texorpdfstring{wireless\+\_\+init(void)}{wireless_init(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool wireless\+\_\+init (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{wireless_8c_a5fa8d063b8e42f0e8c11bf76cbddedd0}{}\label{wireless_8c_a5fa8d063b8e42f0e8c11bf76cbddedd0}
Initializes nordic driver layer and the mesh network layer. This is already called before \hyperlink{startup_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main()} function is run. \begin{DoxyReturn}{Returns}
true if everything is successful. 
\end{DoxyReturn}
\index{wireless.\+c@{wireless.\+c}!wireless\+\_\+service@{wireless\+\_\+service}}
\index{wireless\+\_\+service@{wireless\+\_\+service}!wireless.\+c@{wireless.\+c}}
\subsubsection[{\texorpdfstring{wireless\+\_\+service(void)}{wireless_service(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void wireless\+\_\+service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{wireless_8c_a62b57561d26f95a86a1e16d470aa95c0}{}\label{wireless_8c_a62b57561d26f95a86a1e16d470aa95c0}
Calls \hyperlink{mesh_8c_a03cc4bb7106a1f1b3ee8c69904a38cb2}{mesh\+\_\+service()} routine. This is encapsulated because this function will only call \hyperlink{mesh_8c_a03cc4bb7106a1f1b3ee8c69904a38cb2}{mesh\+\_\+service()} when there is either a pending packet or a packet received as indicated by nordic interrupt. This function is called through R\+IT or through Free\+R\+T\+OS tick hook, so you don\textquotesingle{}t have to call it yourself. 